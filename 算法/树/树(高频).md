# 树(Tree)

树在iOS的面试题中是绝对的高频题，为何要这么说？因为

* 众所周知，iOS编程中的视图(UIView)就是一个N-Node的树形结构，也就是说面试题很容易地就可以和树的题目结合起来。
* 树的题目也涉及到到BFS，DFS，递归等题目，如果要考比较难的算法题，那么这也是一个非常好的主题。

不过，在讨论树的问题之前，我们先来讨论一下递归的思路

## 递归思路

递归是一个非常有趣的思考和解决问题的方式，但是对于没有熟练掌握递归编程思路的程序员来说，对递归总有一些莫名的恐惧（包括刚毕业时候的我）。不过当真正掌握了递归之后，你会觉得递归其实并不是很难。

递归的结构从本质上看，就是一个树形结构，这也是为什么将树要先讲递归。用一个入门级的递归题目作为例子：求第N项斐波那契数列。这是一道最最基本的递归的题目，任何一个接触过递归的人都能够写，甚至是默出来。

假设我们需要求f(4)，那么我们就可以根据递归调用的过程，画出下面的树状结构：



可以递归从本质上来说就是一个函数不断地调用自己的过程，那么在这个过程中，我们可以看到，递归在调用到f(0)和f(1)时就不再向下递归，将直接返回0或1；而我们要求的`f(2)`，则是先求`f(1)`和`f(0)`，然后将两者的返回值相加，并将这一个结果返回f(3)。

上面的这道题目虽然十分基本，但是它却道出了递归的本质。我们也可以将其称为递归三要素，这也是我们在写代码之前需要明确的逻辑：

* 递归结束的条件
* 递归方法在每一层的调用中需要做什么
* 返回值是什么（可以返回空）

这里我们来看看这三要素是如何反映在斐波那契数列这一题中的。

* 结束条件：递归在调用到f(0)和f(1)时就不再向下递归，将直接返回0或1。
* 在每一层的调用中需要做什么: 将`f(x - 1)`与`f(x - 2)`的值相加
* 返回值：返回`f(x- 1)`和`f(x - 2)`的和

以上这三条要素构成了递归的总体思路，明确了这三条逻辑之后，就能够轻松地写出代码。

## 树的遍历(Tree Travsel)

树的遍历主要有两种方式，BFS和DFS，这里就不详细展开了，毕竟这是基础中的基础。下面我们来看一道经典的题目：

打印一个UIView的所有Subviews，并且按照以下的格式

> view1 frame(...  
>
> ​	view11 frame(...		
>
> view2 frame(...		  
>
> ​	view21 frame(		 
>
> ​	 view22 frame(	

这是一道Google Onsite的题目，算是一道热身题，而且这也是一道十分高频的题目。可以看到，按照题目的要求，我们需要先打印`View1`和它所有的Subview，然后再打印`View2`和它所有的子视图。那么我们就需要选用DFS的方式来循环整个视图树。需要注意的是在子视图前面有按照层树的缩进，我们也要在写代码时进行考虑。

这并不是一道十分难的题目，我们只要在进行DFS的时候将当前的层数传导下一层的递归调用就可以了，具体的代码如下：

``` swift
func printAllSubViews(_ view: UIView?) {
  guard let view = view else { return }
  for subview in view.subviews {
    printAllSubViews(subview, 0)    
  }
}

func printAllSubViews(_ view: UIView, _ level: Int) {
    var viewString = ""
    for _ in 0 ..< level {
        viewString += " "
    }
    viewString += view.description
		print(viewString)
    for subview in view.subviews {
        printAllSubViews(subview, level + 1)
    }
}
```

写完之后我们再来回顾一下之前提到的递归三要素吧，具体到这道题里面它们都是什么。

* 结束条件：如果当前的`view`没有`subview`的话，我们就不继续向下递归（隐式）。

* 在每一层的调用中需要做什么: 我们根据传入的层数和`view`建立字符串，并打印；然后对当前`view`的所有`subview` 调用`printAllSubViews(_ view: UIView, _ level: Int)`，并将`level + 1`传入下一层

* 返回值：无，我们已经直接打印了结果。

  

